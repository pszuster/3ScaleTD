// Generated by CoffeeScript 1.9.1
var AuthorizeResponse, Client, Response, VERSION, https, libxml, querystring,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

https = require('https');

querystring = require('qs');

libxml = require('libxmljs');

VERSION = require('../package.json').version;

Response = require('./response');

AuthorizeResponse = require('./authorize_response');


/*
  3Scale client API
  Parameter:
    provider_key {String} Required
    default_host {String} Optional
  Example:
    Client = require('3scale').Client
    client = new Client(provider_key, [default_host])
 */

module.exports = Client = (function() {
  Client.prototype.DEFAULT_HEADERS = {
    "X-3scale-User-Agent": "lambda"
  };

  function Client(provider_key, default_host) {
    if (default_host == null) {
      default_host = "su1.3scale.net";
    }
    if (provider_key == null) {
      throw new Error("missing provider_key");
    }
    this.provider_key = provider_key;
    this.host = default_host;
  }


  /*
    Authorize a application
  
    Parameters:
      options is a Hash object with the following fields
        app_id Required
        app_key Required
        referrer Optional
        usage Optional
      callback {Function} Is the callback function that receives the Response object which includes `is_success`
              method to determine the status of the response
  
    Example:
      client.authorize {app_id: '75165984', app_key: '3e05c797ef193fee452b1ddf19defa74'}, (response) ->
        if response.is_success
           * All Ok
        else
         sys.puts "#{response.error_message} with code: #{response.error_code}"
   */

  Client.prototype.authorize = function(options, callback) {
    var _self, query, req_opts, request, result, url;
    _self = this;
    result = null;
    if ((typeof options !== 'object') || (options.app_id === void 0)) {
      throw "missing app_id";
    }
    url = "/transactions/authorize.xml?";
    query = querystring.stringify(options);
    query += '&' + querystring.stringify({
      provider_key: this.provider_key
    });
    req_opts = {
      host: this.host,
      port: 443,
      path: url + query,
      method: 'GET',
      headers: this.DEFAULT_HEADERS
    };
    request = https.request(req_opts, function(response) {
      var xml;
      response.setEncoding('utf8');
      xml = "";
      response.on('data', function(chunk) {
        return xml += chunk;
      });
      return response.on('end', function() {
        var ref;
        if (response.statusCode === 200 || response.statusCode === 409) {
          return callback(_self._build_success_authorize_response(xml));
        } else if (ref = response.statusCode, indexOf.call([400, 401, 402, 403, 404, 405, 406, 407, 408], ref) >= 0) {
          return callback(_self._build_error_response(xml));
        } else {
          throw "[Client::authorize] Server Error Code: " + response.statusCode;
        }
      });
    });
    return request.end();
  };


  /*
    OAuthorize an Application
    Parameters:
      options is a Hash object with the following fields
        app_id Required
        service_id Optional (In case of mmultiple services)
      callback {Function} Is the callback function that receives the Response object which includes `is_success`
              method to determine the status of the response
  
    Example:
      client.oauth_authorize {app_id: '75165984', (response) ->
        if response.is_success
           * All Ok
        else
         sys.puts "#{response.error_message} with code: #{response.error_code}"
   */

  Client.prototype.oauth_authorize = function(options, callback) {
    var _self, query, req_opts, request, url;
    _self = this;
    if ((typeof options !== 'object') || (options.app_id === void 0)) {
      throw "missing app_id";
    }
    url = "/transactions/oauth_authorize.xml?";
    query = querystring.stringify(options);
    query += '&' + querystring.stringify({
      provider_key: this.provider_key
    });
    req_opts = {
      host: this.host,
      port: 443,
      path: url + query,
      method: 'GET',
      headers: this.DEFAULT_HEADERS
    };
    request = https.request(req_opts, function(response) {
      var xml;
      response.setEncoding('utf8');
      xml = "";
      response.on('data', function(chunk) {
        return xml += chunk;
      });
      return response.on('end', function() {
        var ref;
        if (response.statusCode === 200 || response.statusCode === 409) {
          return callback(_self._build_success_authorize_response(xml));
        } else if (ref = response.statusCode, indexOf.call([400, 401, 402, 403, 404, 405, 406, 407, 408], ref) >= 0) {
          return callback(_self._build_error_response(xml));
        } else {
          throw "[Client::oauth_authorize] Server Error Code: " + response.statusCode;
        }
      });
    });
    return request.end();
  };


  /*
    Authorize with user_key
    Parameters:
      options is a Hash object with the following fields
        user_key Required
        service_id Optional (In case of mmultiple services)
      callback {Function} Is the callback function that receives the Response object which includes `is_success`
              method to determine the status of the response
  
    Example:
      client.authorize_with_user_key {user_key: '123456', (response) ->
        if response.is_success
           * All Ok
        else
         sys.puts "#{response.error_message} with code: #{response.error_code}"
   */

  Client.prototype.authorize_with_user_key = function(options, callback) {
    var _self, query, req_opts, request, url;
    _self = this;
    if ((typeof options !== 'object') || (options.user_key === void 0)) {
      throw "missing user_key";
    }
    url = "/transactions/authorize.xml?";
    query = querystring.stringify(options);
    query += '&' + querystring.stringify({
      provider_key: this.provider_key
    });
    req_opts = {
      host: this.host,
      port: 443,
      path: url + query,
      method: 'GET',
      headers: this.DEFAULT_HEADERS
    };
    request = https.request(req_opts, function(response) {
      var xml;
      response.setEncoding('utf8');
      xml = "";
      response.on('data', function(chunk) {
        return xml += chunk;
      });
      return response.on('end', function() {
        var ref;
        if (response.statusCode === 200 || response.statusCode === 409) {
          return callback(_self._build_success_authorize_response(xml));
        } else if (ref = response.statusCode, indexOf.call([400, 401, 402, 403, 404, 405, 406, 407, 408], ref) >= 0) {
          return callback(_self._build_error_response(xml));
        } else {
          throw "[Client::authorize_with_user_key] Server Error Code: " + response.statusCode;
        }
      });
    });
    return request.end();
  };


  /*
    Authorize and Report in single call
      options is a Hash object with the following fields
        app_id Required
        app_key, user_id, object, usage, no-body, service_id Optional
      callback {Function} Is the callback function that receives the Response object which includes `is_success`
              method to determine the status of the response
  
    Example:
      client.authrep {app_id: '75165984', (response) ->
        if response.is_success
           * All Ok
        else
         sys.puts "#{response.error_message} with code: #{response.error_code}"
   */

  Client.prototype.authrep = function(options, callback) {
    var _self, query, req_opts, request, url;
    _self = this;
    if ((typeof options !== 'object') || (options.app_id === void 0)) {
      throw "missing app_id";
    }
    options.usage || (options.usage = {
      hits: 1
    });
    url = "/transactions/authrep.xml?";
    query = querystring.stringify(options);
    query += '&' + querystring.stringify({
      provider_key: this.provider_key
    });
    req_opts = {
      host: this.host,
      port: 443,
      path: url + query,
      method: 'GET',
      headers: this.DEFAULT_HEADERS
    };
    request = https.request(req_opts, function(response) {
      var xml;
      response.setEncoding('utf8');
      xml = "";
      response.on('data', function(chunk) {
        return xml += chunk;
      });
      return response.on('end', function() {
        var ref;
        if (response.statusCode === 200 || response.statusCode === 409) {
          return callback(_self._build_success_authorize_response(xml));
        } else if (ref = response.statusCode, indexOf.call([400, 401, 402, 403, 404, 405, 406, 407, 408], ref) >= 0) {
          return callback(_self._build_error_response(xml));
        } else {
          throw "[Client::authrep] Server Error Code: " + response.statusCode;
        }
      });
    });
    return request.end();
  };


  /*
    Authorize and Report with :user_key
   */

  Client.prototype.authrep_with_user_key = function(options, callback) {
    var _self, query, req_opts, request, url;
    _self = this;
    if ((typeof options !== 'object') || (options.user_key === void 0)) {
      throw "missing user_key";
    }
    url = "/transactions/authrep.xml?";
    query = querystring.stringify(options);
    query += '&' + querystring.stringify({
      provider_key: this.provider_key
    });
    req_opts = {
      host: this.host,
      port: 443,
      path: url + query,
      method: 'GET',
      headers: this.DEFAULT_HEADERS
    };
    request = https.request(req_opts, function(response) {
      var xml;
      response.setEncoding('utf8');
      xml = "";
      response.on('data', function(chunk) {
        return xml += chunk;
      });
      return response.on('end', function() {
        var ref;
        if (response.statusCode === 200 || response.statusCode === 409) {
          return callback(_self._build_success_authorize_response(xml));
        } else if (ref = response.statusCode, indexOf.call([400, 401, 402, 403, 404, 405, 406, 407, 408], ref) >= 0) {
          return callback(_self._build_error_response(xml));
        } else {
          throw "[Client::authrep_with_user_key] Server Error Code: " + response.statusCode;
        }
      });
    });
    return request.end();
  };


  /*
    Report transaction(s).
  
    Parameters:
      service_id {String} Optional (required only if you have more than one service)
      trans {Array} each array element contain information of a transaction. That information is in a Hash in the form
      {
        app_id {String} Required
        usage {Hash} Required
        timestamp {String} any string parseable by the Data object
      }
      callback {Function} Function that recive the Response object which include a `is_success` method. Required
  
    Example:
      trans = [
        { "app_id": "abc123", "usage": {"hits": 1}},
        { "app_id": "abc123", "usage": {"hits": 1000}}
      ]
  
      client.report trans, (response) ->
        if response.is_success
           * All Ok
        else
         sys.puts "#{response.error_message} with code: #{response.error_code}"
   */

  Client.prototype.report = function(service_id, trans, callback) {
    var _self, key, params, query, ref, req_opts, request, url, value;
    _self = this;
    if ((typeof service_id === 'object') && (typeof trans === 'function')) {
      callback = trans;
      trans = service_id;
      service_id = void 0;
    }
    if (trans == null) {
      throw new Error("no transactions to report");
    }
    url = "/transactions.xml";
    params = {
      transactions: trans,
      provider_key: this.provider_key
    };
    if (service_id) {
      params.service_id = service_id;
    }
    query = querystring.stringify(params).replace(/\[/g, "%5B").replace(/\]/g, "%5D");
    req_opts = {
      host: this.host,
      port: 443,
      path: url,
      method: 'POST',
      headers: {
        "host": this.host,
        "Content-Type": "application/x-www-form-urlencoded",
        "Content-Length": query.length
      }
    };
    ref = this.DEFAULT_HEADERS;
    for (key in ref) {
      value = ref[key];
      req_opts.headers[key] = value;
    }
    request = https.request(req_opts, function(response) {
      var xml;
      xml = "";
      response.on("data", function(data) {
        return xml += data;
      });
      return response.on('end', function() {
        if (response.statusCode === 202) {
          response = new Response();
          response.success();
          return callback(response);
        } else if (response.statusCode === 403) {
          return callback(_self._build_error_response(xml));
        }
      });
    });
    request.write(query);
    return request.end();
  };

  Client.prototype._build_success_authorize_response = function(xml) {
    var authorize, doc, fn, index, plan, reason, ref, response, usage_report, usage_reports;
    response = new AuthorizeResponse();
    doc = libxml.parseXml(xml);
    authorize = doc.get('//authorized').text();
    plan = doc.get('//plan').text();
    if (authorize === 'true') {
      response.success();
    } else {
      reason = doc.get('//reason').text();
      response.error(reason);
    }
    usage_reports = doc.get('//usage_reports');
    if (usage_reports) {
      ref = usage_reports.childNodes();
      fn = function(usage_report) {
        var report;
        report = {
          period: usage_report.attr('period').value(),
          metric: usage_report.attr('metric').value(),
          period_start: this.period === !'eternity' ? usage_report.get('period_start').text() : void 0,
          period_end: this.period === !'eternity' ? usage_report.get('period_end').text() : void 0,
          current_value: usage_report.get('current_value').text(),
          max_value: usage_report.get('max_value').text()
        };
        return response.add_usage_reports(report);
      };
      for (index in ref) {
        usage_report = ref[index];
        fn(usage_report);
      }
    }
    return response;
  };

  Client.prototype._build_error_response = function(xml) {
    var doc, error, response;
    response = new AuthorizeResponse();
    doc = libxml.parseXml(xml);
    error = doc.get('/error');
    response = new Response();
    response.error(error.text(), error.attr('code').value());
    return response;
  };

  return Client;

})();
