
import ll = require("../lowLevelAST");
import hl = require("../highLevelAST");
import hlimpl = require("../highLevelImpl");
import yaml = require("yaml-ast-parser");
import proxy = require("./LowLevelASTProxy");
import RamlWrapper = require("../artifacts/raml10parserapi");
import referencePatcher = require("./referencePatcher");
export declare function expandTraitsAndResourceTypes<T>(api: T): T;
export declare function expandTraitsAndResourceTypesHL(api: hl.IHighLevelNode): hl.IHighLevelNode;
export declare function expandLibraries(api: RamlWrapper.Api): RamlWrapper.Api;
export declare function expandLibrary(lib: RamlWrapper.Library): RamlWrapper.Library;
export declare function expandLibrariesHL(api: hl.IHighLevelNode): hl.IHighLevelNode;
export declare function expandLibraryHL(lib: hl.IHighLevelNode): hl.IHighLevelNode;
export declare function mergeAPIs(masterUnit: ll.ICompilationUnit, extensionsAndOverlays: ll.ICompilationUnit[], mergeMode: hlimpl.OverlayMergeMode): hl.IHighLevelNode;
export declare class TraitsAndResourceTypesExpander {
    private ramlVersion;
    expandTraitsAndResourceTypes(api: hl.IHighLevelNode, rp?: referencePatcher.ReferencePatcher, forceProxy?: boolean): hl.IHighLevelNode;
    init(api: hl.IHighLevelNode): void;
    expandHighLevelNode(hlNode: hl.IHighLevelNode, rp: referencePatcher.ReferencePatcher, api: hl.IHighLevelNode, forceExpand?: boolean): hl.IHighLevelNode;
    private getTemplate<T>(name, context, cache, globalList);
    createHighLevelNode(_api: hl.IHighLevelNode, merge?: boolean, rp?: referencePatcher.ReferencePatcher, forceProxy?: boolean): hl.IHighLevelNode;
    private processResource(resource, _nodes?);
    private mergeBodiesForMethod(method);
    private mergeBodies(bodyNode, defaultMediaType);
    private collectResourceData(original, obj, arr?, transformer?, nodesChain?, occuredResourceTypes?);
    private extractTraits(obj, _transformer, nodesChain, occuredTraits?);
    private readGenerictData(r, obj, context, template, transformer, unitsChain?);
}
export declare class LibraryExpander {
    expandLibraries(_api: hl.IHighLevelNode): hl.IHighLevelNode;
    expandLibrary(_lib: hl.IHighLevelNode): hl.IHighLevelNode;
    processNode(rp: referencePatcher.ReferencePatcher, hlNode: hl.IHighLevelNode): void;
}
export declare function toUnits(node: hl.IParseResult): ll.ICompilationUnit[];
export declare function getTransformNames(): string[];
export declare function getTransformersForOccurence(occurence: string): any[];
export declare class ValueTransformer implements proxy.ValueTransformer {
    templateKind: string;
    templateName: string;
    unitsChain: ll.ICompilationUnit[];
    params: {
        [key: string]: string;
    };
    structuredParams: {
        [key: string]: ll.ILowLevelASTNode;
    };
    vDelegate: ValueTransformer;
    constructor(templateKind: string, templateName: string, unitsChain: ll.ICompilationUnit[], params?: {
        [key: string]: string;
    }, structuredParams?: {
        [key: string]: ll.ILowLevelASTNode;
    }, vDelegate?: ValueTransformer);
    transform(obj: any, toString?: boolean, doBreak?: () => boolean, callback?: (obj: any, transformer: DefaultTransformer) => any): {
        value: any;
        errors: hl.ValidationIssue[];
    };
    private paramUpperBound(str, pos);
    children(node: ll.ILowLevelASTNode): ll.ILowLevelASTNode[];
    valueKind(node: ll.ILowLevelASTNode): yaml.Kind;
    anchorValueKind(node: ll.ILowLevelASTNode): yaml.Kind;
    includePath(node: ll.ILowLevelASTNode): string;
    private substitutionNode(node);
    private paramName(node);
    definingUnitSequence(str: string): ll.ICompilationUnit[];
    _definingUnitSequence(str: string): ll.ICompilationUnit[];
}
export declare class DefaultTransformer extends ValueTransformer {
    owner: hl.IHighLevelNode;
    delegate: ValueTransformer;
    constructor(owner: hl.IHighLevelNode, delegate: ValueTransformer, unitsChain: ll.ICompilationUnit[]);
    transform(obj: any, toString?: boolean, doContinue?: () => boolean, callback?: (obj: any, transformer: DefaultTransformer) => any): any;
    private initParams();
    children(node: ll.ILowLevelASTNode): ll.ILowLevelASTNode[];
    valueKind(node: ll.ILowLevelASTNode): yaml.Kind;
    includePath(node: ll.ILowLevelASTNode): string;
    anchorValueKind(node: ll.ILowLevelASTNode): yaml.Kind;
    _definingUnitSequence(str: string): ll.ICompilationUnit[];
}
