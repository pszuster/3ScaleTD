/// <reference path="../../typings/main.d.ts" />
import ts = require("./typesystem");
import { Status } from "./typesystem";
import tsInterfaces = require("./typesystem-interfaces");
export declare class MetaInfo extends ts.TypeInformation {
    private _name;
    private _value;
    constructor(_name: string, _value: any, inhertitable?: boolean);
    value(): any;
    requiredType(): ts.RootType;
    facetName(): string;
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class Description extends MetaInfo {
    constructor(value: string);
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class NotScalar extends MetaInfo {
    constructor();
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class DisplayName extends MetaInfo {
    constructor(value: string);
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class Usage extends MetaInfo {
    constructor(value: string);
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class Annotation extends MetaInfo implements tsInterfaces.IAnnotation {
    constructor(name: string, value: any);
    private _ownerFacet;
    validateSelf(registry: ts.TypeRegistry, ofExample?: boolean): ts.Status;
    kind(): tsInterfaces.MetaInformationKind;
    ownerFacet(): tsInterfaces.ITypeFacet;
    setOwnerFacet(ownerFacet: tsInterfaces.ITypeFacet): void;
}
export declare class FacetDeclaration extends MetaInfo {
    private name;
    private _type;
    private optional;
    private builtIn;
    constructor(name: string, _type: ts.AbstractType, optional: boolean, builtIn?: boolean);
    actualName(): string;
    isOptional(): boolean;
    type(): ts.AbstractType;
    kind(): tsInterfaces.MetaInformationKind;
    isBuiltIn(): boolean;
}
export declare class CustomFacet extends MetaInfo {
    constructor(name: string, value: any);
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class Example extends MetaInfo {
    constructor(value: any);
    validateSelf(registry: ts.TypeRegistry): ts.Status;
    validateValue(registry: ts.TypeRegistry): ts.Status;
    validateAnnotations(registry: ts.TypeRegistry): ts.Status;
    example(): any;
    asXMLString(): string;
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class Required extends MetaInfo {
    constructor(value: any);
    validateSelf(registry: ts.TypeRegistry): ts.Status;
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class HasPropertiesFacet extends MetaInfo {
    constructor();
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class AllowedTargets extends MetaInfo {
    constructor(value: any);
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class Examples extends MetaInfo {
    constructor(value: any);
    examples(): any[];
    asXMLStrings(): string[];
    validateSelf(registry: ts.TypeRegistry): ts.Status;
    private checkScalarProperty(exampleObj, exampleName, y, registry, status);
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class XMLInfo extends MetaInfo {
    constructor(o: any);
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class Default extends MetaInfo {
    constructor(value: any);
    validateSelf(registry: ts.TypeRegistry): ts.Status;
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class Discriminator extends ts.TypeInformation {
    property: string;
    constructor(property: string);
    requiredType(): ts.InheritedType;
    value(): string;
    facetName(): string;
    validateSelf(registry: ts.TypeRegistry): ts.Status;
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class DiscriminatorValue extends ts.Constraint {
    _value: any;
    protected strict: boolean;
    constructor(_value: any, strict?: boolean);
    check(i: any, path: tsInterfaces.IValidationPath): Status;
    facetName(): string;
    validateSelf(registry: ts.TypeRegistry): ts.Status;
    requiredType(): ts.InheritedType;
    value(): any;
    kind(): tsInterfaces.MetaInformationKind;
    isStrict(): boolean;
}
